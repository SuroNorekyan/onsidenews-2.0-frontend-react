let’s get your Admin Dashboard fully multilingual. Below is a drop‑in plan + code you can hand to Codex. It adds three language editors (HY/RU/EN) for title, content, tags, a Base language selector, and wires the create/update mutations to the backend’s contents[] shape.

What we’ll add

A HY/RU/EN tabbed editor in the form (each tab: Title, Markdown Content, Tags CSV).

A Base language <select> (HY/RU/EN) that defines the canonical version.

Mutations switched to multilingual payloads:

CreatePostInput: baseLanguage, isTop, imageUrl, contents: [PostContentInput!]!

UpdatePostInput: baseLanguage?, contents: [UpsertPostContentInput!]!

When editing a post, we fetch all languages and prefill the three editors.

On submit, we build contents[] from whatever languages have values.
(If you leave a language empty, it’s simply not sent.)

We won’t remove your legacy path—but the UI will prefer the multilingual one.

1) GraphQL (frontend) — add multilingual mutations & a “contents” query

src/graphql/mutations.ts

import { gql } from "@apollo/client";

export const CREATE_POST_ML = gql`
  mutation CreatePostML($input: CreatePostInput!) {
    createPost(input: $input) {
      postId
      baseLanguage
      servedLanguage
      contentResolved { language title }
    }
  }
`;

export const UPDATE_POST_ML = gql`
  mutation UpdatePostML($id: Int!, $input: UpdatePostInput!) {
    updatePost(id: $id, input: $input) {
      postId
      baseLanguage
      servedLanguage
      contentResolved { language title }
    }
  }
`;


src/graphql/queries.ts (add a “for admin edit” query that fetches all contents)

import { gql } from "@apollo/client";

export const GET_POST_WITH_CONTENTS = gql`
  query GetPostWithContents($id: Int!) {
    post(id: $id) {
      postId
      imageUrl
      isTop
      baseLanguage
      contents {
        language
        title
        content
        tags
      }
    }
  }
`;


Your existing public list/detail queries can stay as they are.

2) AdminDashboard — state & UI for three languages

We’ll keep your existing form fields, but replace the single Title/Content/Tags with a tabbed multilingual editor. We’ll also keep imageUrl, isTop, etc.

a) Add helpers & types at the top
type Lang = "HY" | "RU" | "EN";
const LANGS: Lang[] = ["HY", "RU", "EN"];
const LANG_LABEL: Record<Lang, string> = { HY: "Հայերեն", RU: "Русский", EN: "English" };

type LangBundle = { title: string; content: string; tags: string }; // tags CSV per lang

type AdminForm = {
  postId: number;
  imageUrl: string;
  isTop: boolean;
  baseLanguage: Lang;
  // three language bundles
  bundles: Record<Lang, LangBundle>;
};

const emptyBundle: LangBundle = { title: "", content: "", tags: "" };

const emptyFormML: AdminForm = {
  postId: 0,
  imageUrl: "",
  isTop: false,
  baseLanguage: "EN",
  bundles: {
    HY: { ...emptyBundle },
    RU: { ...emptyBundle },
    EN: { ...emptyBundle },
  },
};

b) Replace the old form with the multilingual form

Find:

const [form, setForm] = useState({ ...emptyForm });


Replace with:

const [form, setForm] = useState<AdminForm>({ ...emptyFormML });
const [activeLang, setActiveLang] = useState<Lang>("EN");

c) Adjust mutations to use the new ones

Find the imports:

import { CREATE_POST, UPDATE_POST, DELETE_POST } from "../../graphql/mutations";


Change to:

import { CREATE_POST_ML, UPDATE_POST_ML, DELETE_POST } from "../../graphql/mutations";


And update the hooks:

const [createPost, { loading: creating }] = useMutation(CREATE_POST_ML, {
  onCompleted: () => {
    setFeedback("Post created");
    setForm({ ...emptyFormML });
    refreshLists();
  },
  onError: (e) => setFeedback(e.message),
});

const [updatePost, { loading: updating }] = useMutation(UPDATE_POST_ML, {
  onCompleted: () => {
    setFeedback("Post updated");
    setForm({ ...emptyFormML });
    setEditingId(null);
    refreshLists();
  },
  onError: (e) => setFeedback(e.message),
});

d) When loading a post for editing, fetch all contents

Find fetchPostForEdit and replace with:

import { GET_POST_WITH_CONTENTS } from "../../graphql/queries";

// …

const fetchPostForEdit = async (id: number | string) => {
  try {
    const numericId = Number(id);
    const { data } = await apollo.query({
      query: GET_POST_WITH_CONTENTS,
      variables: { id: numericId },
      fetchPolicy: "network-only",
    });
    const p = data.post;
    // Build bundles from p.contents
    const nextBundles: Record<Lang, LangBundle> = {
      HY: { ...emptyBundle },
      RU: { ...emptyBundle },
      EN: { ...emptyBundle },
    };
    if (p?.contents?.length) {
      for (const c of p.contents) {
        const lang = (c.language as Lang);
        nextBundles[lang] = {
          title: c.title ?? "",
          content: c.content ?? "",
          tags: (c.tags ?? []).join(", "),
        };
      }
    }

    setForm({
      postId: Number(p.postId),
      imageUrl: p.imageUrl ?? "",
      isTop: !!p.isTop,
      baseLanguage: (p.baseLanguage as Lang) || "EN",
      bundles: nextBundles,
    });
  } catch (e) {
    console.error(e);
    setFeedback("Failed to load post");
  }
};

e) Build a multilingual payload on submit

Replace your submit with:

const submit = (e: React.FormEvent) => {
  e.preventDefault();
  setFeedback("");

  // Build contents[] from non-empty bundles
  const contents = LANGS.flatMap((lang) => {
    const b = form.bundles[lang];
    const hasAny = (b.title?.trim() || b.content?.trim() || b.tags?.trim());
    if (!hasAny) return [];
    return [{
      language: lang,
      title: b.title.trim(),
      content: b.content,
      tags: (b.tags || "")
        .split(",")
        .map(t => t.trim())
        .filter(Boolean),
    }];
  });

  if (contents.length === 0) {
    setFeedback("Please fill at least one language (title/content/tags).");
    return;
  }

  // Optional: union of all tags for top-level tag aggregation if your backend still requires it
  const allTags = Array.from(new Set(
    contents.flatMap(c => c.tags || [])
  ));

  const payload: any = {
    baseLanguage: form.baseLanguage,
    isTop: !!form.isTop,
    imageUrl: form.imageUrl?.trim() || undefined,
    contents,
    // tags: allTags, // include only if your backend still requires top-level tags
  };

  if (editingId !== null) {
    updatePost({ variables: { id: Number(editingId), input: payload } });
  } else {
    createPost({ variables: { input: payload } });
  }
};

f) Replace the single‑language inputs with HY/RU/EN tabs

In the Post Form section, replace your Title/Tags/Content inputs with this block:

<section className="rounded-2xl border p-4 space-y-4">
  <h2 className="text-xl font-semibold">
    {editingId ? "Edit Post" : "Create Post"}
  </h2>

  <form onSubmit={submit} className="space-y-4">

    {/* Meta row */}
    <div className="grid md:grid-cols-3 gap-4">
      <div>
        <label className="block text-sm mb-1">Image URL</label>
        <input
          className="w-full rounded-lg border px-3 py-2 bg-transparent"
          value={form.imageUrl}
          onChange={(e) => setForm({ ...form, imageUrl: e.target.value })}
          placeholder="https://…"
        />
      </div>

      <div>
        <label className="block text-sm mb-1">Base language</label>
        <select
          className="w-full rounded-lg border px-3 py-2 bg-transparent"
          value={form.baseLanguage}
          onChange={(e) => setForm({ ...form, baseLanguage: e.target.value as Lang })}
        >
          {LANGS.map(l => <option key={l} value={l}>{LANG_LABEL[l]} ({l})</option>)}
        </select>
      </div>

      <div className="flex items-center gap-2 pt-6">
        <input
          id="isTop"
          type="checkbox"
          className="w-4 h-4"
          checked={form.isTop}
          onChange={(e) => setForm({ ...form, isTop: e.target.checked })}
        />
        <label htmlFor="isTop" className="text-sm">Mark as Top</label>
      </div>
    </div>

    {/* Tabs */}
    <div className="border rounded-xl">
      <div className="flex gap-2 p-2 border-b overflow-x-auto">
        {LANGS.map(l => (
          <button
            key={l}
            type="button"
            onClick={() => setActiveLang(l)}
            className={clsx(
              "px-3 py-1.5 rounded-lg text-sm",
              activeLang === l
                ? "bg-gray-900 text-white dark:bg-gray-100 dark:text-black"
                : "bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-200 hover:bg-gray-200 dark:hover:bg-gray-700"
            )}
          >
            {LANG_LABEL[l]} <span className="opacity-60 ml-1">({l})</span>
          </button>
        ))}
      </div>

      {/* Active language panel */}
      <div className="p-3 space-y-3">
        <div>
          <label className="block text-sm mb-1">Title ({activeLang})</label>
          <input
            className="w-full rounded-lg border px-3 py-2 bg-transparent"
            value={form.bundles[activeLang].title}
            onChange={(e) =>
              setForm({
                ...form,
                bundles: {
                  ...form.bundles,
                  [activeLang]: { ...form.bundles[activeLang], title: e.target.value },
                },
              })
            }
          />
        </div>

        <div className="break-words">
          <label className="block text-sm mb-2">Content ({activeLang}) — Markdown</label>
          <MarkdownEditor
            value={form.bundles[activeLang].content}
            onChange={(v: any) =>
              setForm({
                ...form,
                bundles: {
                  ...form.bundles,
                  [activeLang]: { ...form.bundles[activeLang], content: v },
                },
              })
            }
          />
        </div>

        <div>
          <label className="block text-sm mb-1">Tags ({activeLang}) — comma separated</label>
          <input
            className="w-full rounded-lg border px-3 py-2 bg-transparent"
            value={form.bundles[activeLang].tags}
            onChange={(e) =>
              setForm({
                ...form,
                bundles: {
                  ...form.bundles,
                  [activeLang]: { ...form.bundles[activeLang], tags: e.target.value },
                },
              })
            }
            placeholder="barcelona, messi, laliga"
          />
        </div>
      </div>
    </div>

    <div className="flex items-center gap-3">
      <button
        type="submit"
        disabled={isBusy}
        className={clsx(
          "px-4 py-2 rounded-xl text-white",
          isBusy ? "bg-gray-400" : "bg-red-600 hover:bg-red-700"
        )}
      >
        {editingId ? (isBusy ? "Saving…" : "Save Changes") : (isBusy ? "Creating…" : "Create Post")}
      </button>

      {editingId && (
        <button
          type="button"
          onClick={cancelEdit}
          className="px-4 py-2 rounded-xl bg-gray-200 dark:bg-gray-800 hover:bg-gray-300 dark:hover:bg-gray-700"
        >
          Cancel
        </button>
      )}
    </div>
  </form>
</section>


We removed the old single Title/Content/Tags inputs; everything is now per‑language.

3) Ask Codex to implement this (copy‑paste)
Update Admin Dashboard for full multilingual create/update:

1) Add types and constants for HY/RU/EN and a new AdminForm with bundles per language (title/content/tags CSV) and baseLanguage.
   - See the code provided by the user: LANGS, LANG_LABEL, AdminForm, emptyBundle, emptyFormML.

2) Replace single-language form state with the new AdminForm and add activeLang tab state.

3) Import and use the multilingual mutations CREATE_POST_ML and UPDATE_POST_ML; add GET_POST_WITH_CONTENTS query for editing.

4) Modify fetchPostForEdit to call GET_POST_WITH_CONTENTS and prefill form.bundles[HY|RU|EN] and baseLanguage.

5) Replace the legacy Title/Content/Tags inputs with a tabbed editor for HY/RU/EN (Title, MarkdownEditor, Tags CSV), plus Base language select, Image URL, and Top checkbox. Use Tailwind styles as in the provided snippet.

6) On submit, build input.contents[] from any non-empty language bundle, split tags CSV into arrays, include baseLanguage and isTop/imageUrl; optionally compute a union of tags for top-level tags if required. Call UPDATE_POST_ML or CREATE_POST_ML accordingly.

7) Keep search/list/pagination code as is.

8) Verify:
   - Creating a post with all 3 languages succeeds (contents rows get created).
   - Editing loads existing contents and allows per-language changes.
   - After create/update, refetch list and show success feedback.